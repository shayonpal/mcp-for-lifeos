/**
 * Implementation Contracts for Linear Issue: MCP-37
 * Issue: Add format parameter to search/list tools for concise vs detailed responses
 *
 * These contracts define the expected behavior and data structures for the implementation.
 * All implementation code MUST conform to these interface definitions.
 *
 * Contract Design Rationale:
 * - Extends existing UniversalSearchOptions and UniversalListOptions interfaces
 * - Follows established optional parameter pattern (similar to includeContent)
 * - Maintains backward compatibility with 'detailed' default
 * - Applies format at presentation boundary, not domain layer
 */

// ============================================================================
// EXISTING INTERFACES TO EXTEND
// ============================================================================

/**
 * Base interface from src/tool-router.ts (lines 27-63)
 * This contract extends UniversalSearchOptions with format parameter
 */
export interface UniversalSearchOptionsWithFormat {
  // All existing UniversalSearchOptions properties remain
  query?: string;
  mode?: 'auto' | 'advanced' | 'quick' | 'content_type' | 'recent' | 'pattern';
  contentQuery?: string;
  titleQuery?: string;
  naturalLanguage?: string;
  contentType?: string | string[];
  category?: string;
  subCategory?: string;
  tags?: string[];
  author?: string[];
  people?: string[];
  yamlProperties?: Record<string, any>;
  matchMode?: 'all' | 'any';
  arrayMode?: 'exact' | 'contains' | 'any';
  includeNullValues?: boolean;
  createdAfter?: Date;
  createdBefore?: Date;
  modifiedAfter?: Date;
  modifiedBefore?: Date;
  folder?: string;
  excludeFolders?: string[];
  caseSensitive?: boolean;
  useRegex?: boolean;
  includeContent?: boolean;
  maxResults?: number;
  sortBy?: 'relevance' | 'created' | 'modified' | 'title';
  sortOrder?: 'asc' | 'desc';
  dateStart?: string;
  dateEnd?: string;
  pattern?: string;
  days?: number;

  // NEW: Format parameter for token optimization
  /**
   * Response format mode for controlling output verbosity
   *
   * @param concise - Returns minimal data (title + path only, ~50-100 tokens/result)
   * @param detailed - Returns full metadata including excerpts, YAML properties, match context (~200-500 tokens/result)
   * @default 'detailed' - Maintains backward compatibility with existing clients
   *
   * WHEN TO USE:
   * - concise: Quick lookups, high-level browsing, large result sets, token budget constraints
   * - detailed: Deep analysis, content verification, metadata inspection, comprehensive review
   */
  format?: 'concise' | 'detailed';
}

/**
 * Base interface from src/tool-router.ts (lines 86-95)
 * This contract extends UniversalListOptions with format parameter
 */
export interface UniversalListOptionsWithFormat {
  // All existing UniversalListOptions properties remain
  type: 'folders' | 'daily_notes' | 'templates' | 'yaml_properties' | 'auto';
  path?: string; // For folders
  limit?: number; // For daily_notes
  includeCount?: boolean; // For yaml_properties
  sortBy?: string; // For yaml_properties
  excludeStandard?: boolean; // For yaml_properties

  // NEW: Format parameter for token optimization
  /**
   * Response format mode for controlling output verbosity
   *
   * @param concise - Returns minimal data based on list type:
   *   - folders: Already minimal (string[])
   *   - daily_notes: Already minimal (string[])
   *   - templates: key + name only (~40-50 tokens/template vs ~150-200)
   *   - yaml_properties: property names array (vs object with counts)
   * @param detailed - Returns full metadata (current behavior)
   * @default 'detailed' - Maintains backward compatibility
   */
  format?: 'concise' | 'detailed';
}

// ============================================================================
// FORMATTING OUTPUT CONTRACTS
// ============================================================================

/**
 * Concise search result format (presentation layer)
 * Used when format='concise' is specified
 */
export interface ConciseSearchResult {
  /**
   * Search result title (extracted via ObsidianLinks.extractNoteTitle)
   * Priority: YAML frontmatter 'title' > formatted date > title-cased filename
   */
  title: string;

  /**
   * Relative path from vault root
   * Example: "Daily Notes/2025-01-20.md"
   */
  path: string;
}

/**
 * Detailed search result format (presentation layer)
 * Used when format='detailed' or format is not specified (default)
 * This is the CURRENT behavior - must remain unchanged
 */
export interface DetailedSearchResult {
  /**
   * Formatted markdown string with full metadata
   * Includes: title, score, content type, matches, Obsidian link
   * Generated by ObsidianLinks.formatSearchResult()
   */
  formattedResult: string;

  /**
   * Top 3 match contexts with type and text
   * Example: "- *title*: \"Search term found\""
   */
  matchContexts: string[];
}

/**
 * Concise list result format (type-specific)
 */
export type ConciseListResult =
  | string[] // For folders and daily_notes (already minimal)
  | ConciseTemplateInfo[] // For templates (key + name only)
  | string[]; // For yaml_properties (property names only)

/**
 * Template info with minimal fields for concise mode
 */
export interface ConciseTemplateInfo {
  key: string; // Template identifier (e.g., "tpl-restaurant")
  name: string; // Display name (e.g., "Restaurant Template")
}

/**
 * Full template info for detailed mode (existing interface)
 * From src/template-engine-dynamic.ts (lines 8-15)
 */
export interface DetailedTemplateInfo {
  key: string;
  name: string;
  path: string;
  description: string;
  targetFolder?: string;
  contentType?: string;
}

// ============================================================================
// OBSIDIAN LINKS METHOD CONTRACTS
// ============================================================================

/**
 * Enhanced formatSearchResult method signature
 * Location: src/obsidian-links.ts (lines 147-179)
 *
 * ENHANCEMENT CONTRACT:
 * - Add format parameter with default 'detailed'
 * - Maintain existing signature for backward compatibility
 * - Return type unchanged (string)
 *
 * BEHAVIOR:
 * - format='concise': Return "**{index}. {title}** - `{relativePath}`"
 * - format='detailed': Current behavior (full metadata, score, link)
 */
export interface FormatSearchResultContract {
  (
    index: number,
    title: string,
    filePath: string,
    contentType?: string | string[],
    score?: number,
    additionalInfo?: string,
    format?: 'concise' | 'detailed' // NEW parameter
  ): string;
}

/**
 * New formatListResult method signature
 * Location: src/obsidian-links.ts (to be added)
 *
 * PURPOSE:
 * - Unified list formatting with format parameter support
 * - Type-specific concise formatters for each list type
 * - Extracts inline formatting from case handlers
 *
 * BEHAVIOR:
 * - Switch on listType to apply appropriate formatting
 * - format='concise': Type-specific minimal output
 * - format='detailed': Full metadata output
 */
export interface FormatListResultContract {
  (
    items: string[] | DetailedTemplateInfo[] | Record<string, number>,
    listType: 'folders' | 'daily_notes' | 'templates' | 'yaml_properties',
    format?: 'concise' | 'detailed'
  ): string;
}

// ============================================================================
// CASE HANDLER CONTRACTS
// ============================================================================

/**
 * Search case handler contract (src/index.ts:908-934)
 *
 * MODIFICATIONS REQUIRED:
 * 1. Extract format parameter from args (default 'detailed')
 * 2. Conditionally skip match context extraction if format='concise'
 * 3. Pass format to ObsidianLinks.formatSearchResult()
 *
 * PERFORMANCE OPTIMIZATION:
 * - Skip match.slice(0, 3) processing when format='concise'
 * - Skip match.context string generation when format='concise'
 * - Reduces string allocations and processing overhead
 */
export interface SearchCaseHandlerContract {
  /**
   * Extract format parameter with proper fallback
   */
  format: 'concise' | 'detailed';

  /**
   * Conditional match context processing
   * ONLY process if format='detailed'
   */
  shouldProcessMatchContext: boolean;

  /**
   * Pass format to formatter
   */
  formattedOutput: string; // From ObsidianLinks.formatSearchResult(..., format)
}

/**
 * List case handler contract (src/index.ts:989-1031)
 *
 * MODIFICATIONS REQUIRED:
 * 1. Extract format parameter from args (default 'detailed')
 * 2. Replace inline formatting with ObsidianLinks.formatListResult()
 * 3. Pass format to formatter for type-specific handling
 */
export interface ListCaseHandlerContract {
  /**
   * Extract format parameter with proper fallback
   */
  format: 'concise' | 'detailed';

  /**
   * Use unified formatter instead of inline switch/case
   */
  formattedOutput: string; // From ObsidianLinks.formatListResult(items, type, format)
}

// ============================================================================
// MCP TOOL SCHEMA CONTRACTS
// ============================================================================

/**
 * Search tool inputSchema enhancement
 * Location: src/index.ts (lines 92-122)
 *
 * ADD TO PROPERTIES:
 */
export interface SearchToolSchemaAddition {
  format: {
    type: 'string';
    enum: ['concise', 'detailed'];
    description: 'Response format: concise (paths only, ~50-100 tokens/result) or detailed (full metadata, ~200-500 tokens/result, default: detailed)';
  };
}

/**
 * List tool inputSchema enhancement
 * Location: src/index.ts (lines 167-183)
 *
 * ADD TO PROPERTIES:
 */
export interface ListToolSchemaAddition {
  format: {
    type: 'string';
    enum: ['concise', 'detailed'];
    description: 'Response format: concise (minimal fields) or detailed (full metadata, default: detailed)';
  };
}

// ============================================================================
// ERROR CONTRACTS
// ============================================================================

/**
 * Error conditions for format parameter handling
 *
 * EXPECTED BEHAVIOR:
 * - Invalid format values (not 'concise' or 'detailed') → Default to 'detailed'
 * - Undefined/null format → Default to 'detailed' (backward compatibility)
 * - Format parameter should NEVER cause errors
 *
 * NO EXCEPTIONS THROWN:
 * Format is purely presentational - invalid values gracefully fallback to default
 */
export interface FormatErrorHandling {
  /**
   * Invalid format value handling
   * @example format='invalid' → treated as 'detailed'
   */
  invalidFormatFallback: 'detailed';

  /**
   * Missing format handling
   * @example format=undefined → treated as 'detailed'
   */
  missingFormatFallback: 'detailed';

  /**
   * No exceptions thrown for format-related issues
   */
  noFormatExceptions: true;
}

// ============================================================================
// INTEGRATION CONTRACTS
// ============================================================================

/**
 * Integration points that remain UNCHANGED
 *
 * DOMAIN LAYER (format-agnostic):
 * - SearchEngine.search() → No modifications
 * - ToolRouter.executeSearch() → No modifications
 * - ToolRouter.executeList() → No modifications
 * - VaultUtils operations → No modifications
 *
 * PRESENTATION LAYER ONLY:
 * - ObsidianLinks.formatSearchResult() → Add format parameter
 * - ObsidianLinks.formatListResult() → New method
 * - index.ts case handlers → Check format, apply conditionally
 */
export interface IntegrationBoundaries {
  /**
   * Domain layer interfaces that MUST remain unchanged
   */
  unchangedDomainLayer: {
    searchEngine: 'SearchEngine.search() signature unchanged';
    toolRouterSearch: 'ToolRouter.executeSearch() signature unchanged';
    toolRouterList: 'ToolRouter.executeList() signature unchanged';
    vaultUtils: 'VaultUtils methods unchanged';
  };

  /**
   * Presentation layer interfaces that will be enhanced
   */
  enhancedPresentationLayer: {
    obsidianLinksFormat: 'formatSearchResult() gains format parameter';
    obsidianLinksList: 'formatListResult() new method added';
    searchHandler: 'case "search" checks format and applies conditionally';
    listHandler: 'case "list" checks format and applies conditionally';
  };
}

// ============================================================================
// BEHAVIORAL CONTRACTS
// ============================================================================

/**
 * Expected behaviors and guarantees
 *
 * MUST:
 * - Default to 'detailed' when format not specified (backward compatibility)
 * - Skip match context extraction when format='concise' (performance)
 * - Apply format only at presentation boundary (case handlers)
 * - Maintain existing response structure (only detail level changes)
 * - Support all list types in concise mode (type-specific formatters)
 *
 * MUST NOT:
 * - Pass format parameter to SearchEngine or ToolRouter (domain isolation)
 * - Change SearchResult or list response data structures
 * - Break existing clients that don't specify format
 * - Throw exceptions for invalid format values
 * - Modify YAML properties or vault operations based on format
 */
export interface BehavioralGuarantees {
  /**
   * Backward compatibility guarantee
   */
  backwardCompatible: {
    undefinedFormat: 'Treated as detailed mode';
    nullFormat: 'Treated as detailed mode';
    existingClients: 'Get detailed responses (current behavior)';
  };

  /**
   * Performance guarantee
   */
  performanceOptimization: {
    conciseMode: 'Skips expensive match context extraction';
    detailedMode: 'Uses existing match processing (no regression)';
    formatCheck: 'Minimal overhead (single string comparison)';
  };

  /**
   * Architectural guarantee
   */
  architecturalBoundaries: {
    domainLayer: 'Remains format-agnostic (SearchEngine, ToolRouter)';
    presentationLayer: 'Applies format transformation (ObsidianLinks, handlers)';
    separation: 'Clean separation of concerns maintained';
  };

  /**
   * Token optimization guarantee
   */
  tokenReduction: {
    conciseMode: '50-70% fewer tokens than detailed';
    detailedMode: 'Current token usage unchanged';
    listTemplates: '60-70% reduction for templates list';
  };
}

// ============================================================================
// TESTING CONTRACTS
// ============================================================================

/**
 * Required test coverage
 *
 * UNIT TESTS:
 * - ObsidianLinks.formatSearchResult() with concise/detailed/undefined format
 * - ObsidianLinks.formatListResult() for all four list types
 * - Edge cases: invalid format, missing data, empty results
 * - Token counting validation (50-70% reduction in concise)
 *
 * INTEGRATION TESTS:
 * - Search tool handler with format parameter
 * - List tool handler with format parameter
 * - Backward compatibility (undefined/null/missing format)
 * - Performance benchmarks (concise vs detailed timing)
 *
 * MANUAL TESTS:
 * - Claude Desktop tool selection scenarios
 * - AI understanding of format parameter usage
 * - Multi-tool workflows with different formats
 */
export interface TestingRequirements {
  unitTests: {
    formatSearchResult: ['concise', 'detailed', 'undefined', 'invalid'];
    formatListResult: ['folders', 'daily_notes', 'templates', 'yaml_properties'];
    edgeCases: ['empty results', 'missing title', 'null format'];
    tokenCounting: 'Validate 50-70% reduction in concise mode';
  };

  integrationTests: {
    searchHandler: 'With format parameter through ToolRouter';
    listHandler: 'With format parameter through ToolRouter';
    backwardCompatibility: 'Old clients without format parameter';
    performance: 'Measure concise vs detailed execution time';
  };

  manualTests: {
    claudeDesktop: 'AI tool selection scenarios';
    formatSelection: 'Context-aware format choice by AI';
    multiTool: 'Different formats in same workflow';
  };
}

// ============================================================================
// IMPLEMENTATION CHECKLIST
// ============================================================================

/**
 * Implementation validation checklist
 * All items must be verified before considering implementation complete
 */
export interface ImplementationChecklist {
  interfaceUpdates: {
    universalSearchOptions: 'Added format?: "concise" | "detailed"';
    universalListOptions: 'Added format?: "concise" | "detailed"';
  };

  toolSchemas: {
    searchInputSchema: 'Added format enum to properties';
    listInputSchema: 'Added format enum to properties';
    toolDescriptions: 'Updated with format parameter examples';
  };

  obsidianLinks: {
    formatSearchResultEnhanced: 'Added format parameter with default';
    formatListResultCreated: 'New method with type-specific formatters';
    conciseBranches: 'Implemented for both methods';
    detailedBranches: 'Preserved existing behavior';
  };

  caseHandlers: {
    searchHandlerUpdated: 'Extracts format, skips match context if concise';
    listHandlerUpdated: 'Uses formatListResult() with format parameter';
    formatPassing: 'Both handlers pass format to ObsidianLinks';
  };

  testing: {
    unitTestsPassing: 'All ObsidianLinks tests pass';
    integrationTestsPassing: 'All handler tests pass';
    backwardCompatibilityVerified: 'Old clients work unchanged';
    tokenReductionValidated: '50-70% reduction measured';
    performanceImproved: 'Concise mode faster than detailed';
  };

  documentation: {
    toolDescriptionsUpdated: 'In src/index.ts tool definitions';
    docsUpdated: 'docs/tools/search.md and list.md';
    changelogUpdated: 'CHANGELOG.md with feature entry';
    contractsDocumented: 'This file remains as reference';
  };

  typeCheck: {
    compilation: 'npm run typecheck passes';
    noTypeErrors: 'All interfaces properly typed';
    conformance: 'Implementation matches contracts';
  };
}

/**
 * END OF CONTRACTS
 *
 * Usage: Import these contracts in implementation files
 * Validation: Run `npm run typecheck` to verify conformance
 * Reference: Keep this file for code review and validation phases
 */
